"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const signer_1 = require("@taquito/signer");
const taquito_1 = require("@taquito/taquito");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const axios_1 = __importDefault(require("axios"));
const COMPOUND_PERIOD_SECONDS = 60;
const COMPOUNDS_PER_YEAR = (365 * 24 * 60 * 60) / COMPOUND_PERIOD_SECONDS;
const PRECISION = new bignumber_js_1.default(Math.pow(10, 18));
class StableCoinClient {
    constructor(nodeUrl, network, ovenRegistryAddress, minterAddress, ovenFactoryAddress, indexerURL) {
        this.network = network;
        this.ovenRegistryAddress = ovenRegistryAddress;
        this.minterAddress = minterAddress;
        this.ovenFactoryAddress = ovenFactoryAddress;
        this.indexerURL = indexerURL;
        this.tezos = new taquito_1.TezosToolkit(nodeUrl);
    }
    getNetwork() {
        const networkString = this.network.toString();
        return networkString.charAt(0).toUpperCase() + networkString.slice(1);
    }
    async deployOven(wallet) {
        if (wallet instanceof signer_1.InMemorySigner) {
            this.tezos.setProvider({ signer: wallet });
        }
        else {
            this.tezos.setWalletProvider(wallet);
        }
        const ovenFactoryContract = await this.tezos.wallet.at(this.ovenFactoryAddress);
        return ovenFactoryContract.methods.makeOven([['unit']]).send();
    }
    async getStabilityFeeApy() {
        const minterContract = await this.tezos.contract.at(this.minterAddress);
        const minterStorage = await minterContract.storage();
        const stabilityFee = await minterStorage.stabilityFee;
        const one = new bignumber_js_1.default(1000000000000000000);
        const initial = stabilityFee.plus(one);
        let apy = one;
        for (let n = 0; n < COMPOUNDS_PER_YEAR; n++) {
            apy = apy.times(initial).dividedBy(one);
        }
        return apy.minus(one);
    }
    async getSimpleStabilityFee() {
        const minterContract = await this.tezos.contract.at(this.minterAddress);
        const minterStorage = await minterContract.storage();
        return await minterStorage.stabilityFee;
    }
    async getMaximumOvenValue() {
        const minterContract = await this.tezos.contract.at(this.minterAddress);
        const minterStorage = await minterContract.storage();
        return await minterStorage.ovenMax;
    }
    async getRequiredCollateralizationRatio() {
        const minterContract = await this.tezos.contract.at(this.minterAddress);
        const minterStorage = await minterContract.storage();
        return await minterStorage.collateralizationPercentage;
    }
    async getInterestData(time = new Date()) {
        const minterContract = await this.tezos.contract.at(this.minterAddress);
        const minterStorage = await minterContract.storage();
        const globalInterestIndex = await minterStorage.interestIndex;
        const raw = await minterStorage.lastInterestIndexUpdateTime;
        const lastUpdateTime = new Date(`${raw}`);
        const deltaMs = time.getTime() - lastUpdateTime.getTime();
        const deltaSecs = Math.floor(deltaMs / 1000);
        const numPeriods = Math.floor(deltaSecs / COMPOUND_PERIOD_SECONDS);
        const simpleStabilityFee = await this.getSimpleStabilityFee();
        const globalInterestIndexApproximation = globalInterestIndex
            .times(PRECISION.plus(simpleStabilityFee.times(numPeriods)))
            .div(PRECISION);
        return {
            globalInterestIndex: globalInterestIndexApproximation,
            lastUpdateTime: time,
        };
    }
    async getOvenCount() {
        const ovens = await this.getAllOvens();
        return ovens.length;
    }
    async ovensOwnedByAddress(address) {
        const allOvens = await this.getAllOvens();
        return allOvens
            .filter((oven) => {
            return oven.ovenOwner === address;
        })
            .map((oven) => {
            return oven.ovenAddress;
        });
    }
    async getAllOvens() {
        if (this.indexerURL === undefined) {
            const response = await axios_1.default.get(`https://kolibri-data.s3.amazonaws.com/${this.network}/oven-key-data.json`);
            return response.data.ovenData;
        }
        else {
            const ovenRegistryContract = await this.tezos.contract.at(this.ovenRegistryAddress);
            const ovenRegistryStorage = await ovenRegistryContract.storage();
            const ovenRegistryBigMapId = await ovenRegistryStorage.ovenMap;
            let offset = 0;
            const results = [];
            while (true) {
                const values = await axios_1.default.get(`${this.indexerURL}/v1/bigmap/sandboxnet/${ovenRegistryBigMapId}/keys?size=10&offset=${offset}`);
                values.data.forEach((value) => {
                    results.push({
                        ovenAddress: value.data.key.value,
                        ovenOwner: value.data.value.value,
                    });
                });
                if (values.data.length < 10) {
                    break;
                }
                offset += 10;
            }
            return results;
        }
    }
}
exports.default = StableCoinClient;
//# sourceMappingURL=stable-coin-client.js.map