"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotConnectedThanosWalletError = exports.ThanosWallet = void 0;
const taquito_1 = require("@taquito/taquito");
const client_1 = require("./client");
class ThanosWallet {
    constructor(appName, existingPermission) {
        this.appName = appName;
        this.permission = null;
        if (existingPermission) {
            this.permission = existingPermission;
        }
    }
    get connected() {
        return Boolean(this.permission);
    }
    toTezos() {
        assertConnected(this.permission);
        const tezos = new taquito_1.TezosToolkit(this.permission.rpc);
        tezos.setProvider({ wallet: this });
        return tezos;
    }
    async connect(network, opts = { forcePermission: false }) {
        const perm = await client_1.requestPermission(network, { name: this.appName }, opts.forcePermission);
        this.permission = perm;
    }
    reconnect(network) {
        return this.connect(network, { forcePermission: true });
    }
    async getPKH() {
        assertConnected(this.permission);
        return this.permission.pkh;
    }
    async mapTransferParamsToWalletParams(params) {
        return taquito_1.createTransferOperation(params);
    }
    async mapOriginateParamsToWalletParams(params) {
        return taquito_1.createOriginationOperation(params);
    }
    async mapDelegateParamsToWalletParams(params) {
        return taquito_1.createSetDelegateOperation(params);
    }
    async sendOperations(opParams) {
        assertConnected(this.permission);
        return client_1.requestOperation(this.permission.pkh, opParams.map(formatOpParams));
    }
    async sign(payload) {
        assertConnected(this.permission);
        return client_1.requestSign(this.permission.pkh, payload);
    }
    async broadcast(signedOpBytes) {
        assertConnected(this.permission);
        return client_1.requestBroadcast(signedOpBytes);
    }
}
exports.ThanosWallet = ThanosWallet;
ThanosWallet.isAvailable = client_1.isAvailable;
ThanosWallet.onAvailabilityChange = client_1.onAvailabilityChange;
ThanosWallet.getCurrentPermission = client_1.getCurrentPermission;
ThanosWallet.onPermissionChange = client_1.onPermissionChange;
class NotConnectedThanosWalletError extends client_1.ThanosWalletError {
    constructor() {
        super(...arguments);
        this.name = "ThanosWalletNotConnected";
        this.message = "You need to connect ThanosWallet by calling thanosWallet.connect() first";
    }
}
exports.NotConnectedThanosWalletError = NotConnectedThanosWalletError;
function assertConnected(perm) {
    if (!perm) {
        throw new NotConnectedThanosWalletError();
    }
}
function formatOpParams(op) {
    const { fee, gas_limit, storage_limit, ...rest } = op;
    switch (op.kind) {
        case "origination":
            return {
                ...rest,
                mutez: true,
            };
        case "transaction":
            const { destination, amount, parameters, ...txRest } = rest;
            return {
                ...txRest,
                to: destination,
                amount: +amount,
                mutez: true,
                parameter: parameters,
            };
        default:
            return rest;
    }
}
//# sourceMappingURL=taquito-wallet.js.map