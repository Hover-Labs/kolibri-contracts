"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const secp256k1_1 = __importDefault(require("secp256k1"));
const asn1_1 = __importDefault(require("./asn1"));
const base58Check = require('bs58check');
const blakejs = require('blakejs');
const utils = {
    compressKey(uncompressed) {
        const uncompressedKeySize = 65;
        if (uncompressed.length !== uncompressedKeySize) {
            throw new Error('Invalid length for uncompressed key');
        }
        const firstByte = uncompressed[0];
        if (firstByte !== 4) {
            throw new Error('Invalid compression byte');
        }
        const lastByte = uncompressed[64];
        const magicByte = lastByte % 2 === 0 ? 2 : 3;
        const xBytes = uncompressed.slice(1, 33);
        return this.mergeBytes(new Uint8Array([magicByte]), xBytes);
    },
    blake2b(input, length) {
        return blakejs.blake2b(input, null, length);
    },
    normalizeSignature(signature) {
        return secp256k1_1.default.signatureNormalize(signature);
    },
    derSignatureToRaw(derSignature) {
        const decodedSignature = asn1_1.default.decode(derSignature);
        const rHex = decodedSignature.sub[0].toHexStringContent();
        const sHex = decodedSignature.sub[1].toHexStringContent();
        return this.hexToBytes(rHex + sHex);
    },
    base58CheckEncode(bytes, prefix) {
        const prefixedBytes = this.mergeBytes(prefix, bytes);
        return base58Check.encode(prefixedBytes);
    },
    mergeBytes(a, b) {
        const merged = new Uint8Array(a.length + b.length);
        merged.set(a);
        merged.set(b, a.length);
        return merged;
    },
    isHex(input) {
        const hexRegEx = /([0-9]|[a-f])/gim;
        return (input.match(hexRegEx) || []).length === input.length;
    },
    hexToBytes(hex) {
        if (!this.isHex(hex)) {
            throw new Error(`Invalid hex${hex}`);
        }
        return Uint8Array.from(Buffer.from(hex, 'hex'));
    },
};
exports.default = utils;
//# sourceMappingURL=utils.js.map