"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateOracleFromFeedOnce = exports.updateOracleFromFeed = exports.updateOracleFromCoinbaseOnce = void 0;
const common_1 = require("./common");
const utils_1 = __importDefault(require("./utils"));
const conseiljs_1 = require("conseiljs");
const WebRequest = __importStar(require("web-request"));
const constants_1 = __importDefault(require("./constants"));
const push_1 = require("./push");
const crypto = require("crypto");
const operation_fee_estimator_1 = __importDefault(require("./operation-fee-estimator"));
async function updateOracleFromCoinbase(logLevel, apiKeyID, apiSecret, apiPassphrase, oracleContractAddress, assetNames, posterPrivateKey, updateIntervalSeconds, tezosNodeURL, normalizerContractAddress = undefined, enableZeroFees = false) {
    if (logLevel == common_1.LogLevel.Debug) {
        utils_1.default.print('Using node located at: ' + tezosNodeURL);
        utils_1.default.print('');
    }
    const keyStore = await utils_1.default.keyStoreFromPrivateKey(posterPrivateKey);
    const signer = await utils_1.default.signerFromKeyStore(keyStore);
    if (logLevel == common_1.LogLevel.Debug) {
        utils_1.default.print('Updating from account: ' + keyStore.publicKeyHash);
        utils_1.default.print('');
    }
    if (updateIntervalSeconds) {
        while (true) {
            await updateOracleFromCoinbaseOnce(logLevel, apiKeyID, apiSecret, apiPassphrase, oracleContractAddress, assetNames, keyStore, signer, tezosNodeURL, normalizerContractAddress, enableZeroFees);
            utils_1.default.print(`Waiting ${updateIntervalSeconds} seconds to do next update. (Customize with --update-interval)`);
            await utils_1.default.sleep(updateIntervalSeconds);
        }
    }
    else {
        await updateOracleFromCoinbaseOnce(logLevel, apiKeyID, apiSecret, apiPassphrase, oracleContractAddress, assetNames, keyStore, signer, tezosNodeURL, normalizerContractAddress, enableZeroFees);
    }
}
exports.default = updateOracleFromCoinbase;
async function updateOracleFromCoinbaseOnce(logLevel, apiKeyID, apiSecret, apiPassphrase, oracleContractAddress, assetNames, keyStore, signer, tezosNodeURL, normalizerContractAddress = undefined, enableZeroFees = false) {
    try {
        await utils_1.default.revealAccountIfNeeded(tezosNodeURL, keyStore, signer);
        utils_1.default.print('Updating oracle located at: ' + oracleContractAddress);
        if (logLevel == common_1.LogLevel.Debug) {
            utils_1.default.print('Using assets: ' +
                assetNames.reduce((previousValue, assetName) => {
                    return previousValue + assetName + ', ';
                }, ''));
        }
        utils_1.default.print('');
        const counter = await conseiljs_1.TezosNodeReader.getCounterForAccount(tezosNodeURL, keyStore.publicKeyHash);
        const operations = [];
        const operation = await makeUpdateOperationFromCoinbase(logLevel, apiKeyID, apiSecret, apiPassphrase, assetNames, keyStore, oracleContractAddress, counter + 1);
        operations.push(operation);
        if (normalizerContractAddress !== undefined) {
            const normalizerPushOperation = push_1.constructPushOperation(logLevel, keyStore, counter + 2, oracleContractAddress, normalizerContractAddress);
            operations.push(normalizerPushOperation);
        }
        const operationFeeEstimator = new operation_fee_estimator_1.default(tezosNodeURL, enableZeroFees);
        const operationsWithFees = await operationFeeEstimator.estimateAndApplyFees(operations);
        const nodeResult = await conseiljs_1.TezosNodeWriter.sendOperation(tezosNodeURL, operationsWithFees, signer);
        const hash = nodeResult.operationGroupID.replace(/"/g, '');
        utils_1.default.print('Update sent with hash: ' + hash);
        return hash;
    }
    catch (error) {
        utils_1.default.print('Error occurred while trying to update.');
        if (logLevel == common_1.LogLevel.Debug) {
            utils_1.default.print(error.message);
        }
        utils_1.default.print('');
        return '';
    }
}
exports.updateOracleFromCoinbaseOnce = updateOracleFromCoinbaseOnce;
async function updateOracleFromFeed(logLevel, oracleFeedURL, oracleContractAddress, assetNames, posterPrivateKey, updateIntervalSeconds, tezosNodeURL, normalizerContractAddress = undefined, enableZeroFees = false) {
    if (logLevel == common_1.LogLevel.Debug) {
        utils_1.default.print('Using node located at: ' + tezosNodeURL);
        utils_1.default.print('');
    }
    const keyStore = await utils_1.default.keyStoreFromPrivateKey(posterPrivateKey);
    const signer = await utils_1.default.signerFromKeyStore(keyStore);
    if (logLevel == common_1.LogLevel.Debug) {
        utils_1.default.print('Updating from account: ' + keyStore.publicKeyHash);
        utils_1.default.print('');
    }
    if (updateIntervalSeconds) {
        while (true) {
            await updateOracleFromFeedOnce(logLevel, oracleFeedURL, oracleContractAddress, assetNames, keyStore, signer, tezosNodeURL, normalizerContractAddress, enableZeroFees);
            utils_1.default.print(`Waiting ${updateIntervalSeconds} seconds to do next update. (Customize with --update-interval)`);
            await utils_1.default.sleep(updateIntervalSeconds);
        }
    }
    else {
        await updateOracleFromFeedOnce(logLevel, oracleFeedURL, oracleContractAddress, assetNames, keyStore, signer, tezosNodeURL, normalizerContractAddress, enableZeroFees);
    }
}
exports.updateOracleFromFeed = updateOracleFromFeed;
async function updateOracleFromFeedOnce(logLevel, oracleFeedURL, oracleContractAddress, assetNames, keyStore, signer, tezosNodeURL, normalizerContractAddress = undefined, enableZeroFees = false) {
    try {
        await utils_1.default.revealAccountIfNeeded(tezosNodeURL, keyStore, signer);
        utils_1.default.print('Updating oracle located at: ' + oracleContractAddress);
        if (logLevel == common_1.LogLevel.Debug) {
            utils_1.default.print('Using assets: ' +
                assetNames.reduce((previousValue, assetName) => {
                    return previousValue + assetName + ', ';
                }, ''));
        }
        utils_1.default.print('');
        const counter = await conseiljs_1.TezosNodeReader.getCounterForAccount(tezosNodeURL, keyStore.publicKeyHash);
        const operations = [];
        const operation = await makeUpdateOperationFromFeed(logLevel, oracleFeedURL, assetNames, keyStore, oracleContractAddress, counter + 1);
        operations.push(operation);
        if (normalizerContractAddress !== undefined) {
            const normalizerPushOperation = push_1.constructPushOperation(logLevel, keyStore, counter + 2, oracleContractAddress, normalizerContractAddress);
            operations.push(normalizerPushOperation);
        }
        const operationFeeEstimator = new operation_fee_estimator_1.default(tezosNodeURL, enableZeroFees);
        const operationsWithFees = await operationFeeEstimator.estimateAndApplyFees(operations);
        const nodeResult = await conseiljs_1.TezosNodeWriter.sendOperation(tezosNodeURL, operationsWithFees, signer);
        const hash = nodeResult.operationGroupID.replace(/"/g, '');
        utils_1.default.print('Update sent with hash: ' + hash);
        return hash;
    }
    catch (error) {
        utils_1.default.print('Error occurred while trying to update.');
        if (logLevel == common_1.LogLevel.Debug) {
            utils_1.default.print(error.message);
        }
        utils_1.default.print('');
        return '';
    }
}
exports.updateOracleFromFeedOnce = updateOracleFromFeedOnce;
async function makeUpdateOperationFromCoinbase(logLevel, apiKeyID, apiSecret, apiPassphrase, assetNames, keystore, oracleContractAddress, counter) {
    const oracleData = await retrieveOracleDataFromCoinbase(apiKeyID, apiSecret, apiPassphrase);
    if (logLevel == common_1.LogLevel.Debug) {
        utils_1.default.print('Received oracle data: ');
        utils_1.default.print(oracleData);
        utils_1.default.print('');
    }
    const elements = assetNames.map((assetName) => {
        const element = listElementForAsset(oracleData, assetName);
        if (!element) {
            utils_1.default.print('Unable to locate data for ' + assetName + ' in Oracle data');
            utils_1.default.print('Aborting.');
            process.exit(1);
        }
        return element;
    });
    const elementString = elements
        .reduce((previousValue, element) => {
        return previousValue + element + ';';
    }, '')
        .replace(/'/g, '"');
    const parameter = `{${elementString}}`;
    if (logLevel == common_1.LogLevel.Debug) {
        utils_1.default.print('Made parameter: ');
        utils_1.default.print(parameter);
        utils_1.default.print('');
    }
    const entrypoint = 'update';
    return conseiljs_1.TezosNodeWriter.constructContractInvocationOperation(keystore.publicKeyHash, counter, oracleContractAddress, 0, 0, constants_1.default.storageLimit, constants_1.default.gasLimit, entrypoint, parameter, conseiljs_1.TezosParameterFormat.Michelson);
}
async function makeUpdateOperationFromFeed(logLevel, oracleFeedURL, assetNames, keystore, oracleContractAddress, counter) {
    const oracleData = await retrieveOracleDataFromFeed(oracleFeedURL);
    if (logLevel == common_1.LogLevel.Debug) {
        utils_1.default.print('Received oracle data: ');
        utils_1.default.print(oracleData);
        utils_1.default.print('');
    }
    const elements = assetNames.map((assetName) => {
        const element = listElementForAsset(oracleData, assetName);
        if (!element) {
            utils_1.default.print('Unable to locate data for ' + assetName + ' in Oracle data');
            utils_1.default.print('Aborting.');
            process.exit(1);
        }
        return element;
    });
    const elementString = elements
        .reduce((previousValue, element) => {
        return previousValue + element + ';';
    }, '')
        .replace(/'/g, '"');
    const parameter = `{${elementString}}`;
    if (logLevel == common_1.LogLevel.Debug) {
        utils_1.default.print('Made parameter: ');
        utils_1.default.print(parameter);
        utils_1.default.print('');
    }
    const entrypoint = 'update';
    return conseiljs_1.TezosNodeWriter.constructContractInvocationOperation(keystore.publicKeyHash, counter, oracleContractAddress, 0, 0, constants_1.default.storageLimit, constants_1.default.gasLimit, entrypoint, parameter, conseiljs_1.TezosParameterFormat.Michelson);
}
async function retrieveOracleDataFromFeed(oracleFeedURL) {
    const oracleDataRaw = await WebRequest.get(oracleFeedURL, {
        headers: {
            'User-Agent': 'harbinger',
            accept: 'json',
        },
    });
    if (oracleDataRaw.statusCode != 200) {
        throw new Error(`Failed to retrieve oracle data!\n${oracleDataRaw.statusCode}: ${oracleDataRaw.content}`);
    }
    const oracleData = JSON.parse(oracleDataRaw.content);
    return parseRawOracleData(oracleData);
}
async function retrieveOracleDataFromCoinbase(apiKeyID, apiSecret, apiPassphrase) {
    const apiURL = 'https://api.pro.coinbase.com';
    const requestPath = '/oracle/xtz';
    const timestamp = Date.now() / 1000;
    const method = 'GET';
    const what = `${timestamp}${method}${requestPath}`;
    const secretKey = Buffer.from(apiSecret, 'base64');
    const hmac = crypto.createHmac('sha256', secretKey);
    const signature = hmac.update(what).digest('base64');
    const oracleURL = apiURL + requestPath;
    const oracleDataRaw = await WebRequest.get(oracleURL, {
        headers: {
            'User-Agent': 'harbinger',
            'CB-ACCESS-KEY': apiKeyID,
            'CB-ACCESS-SIGN': signature,
            'CB-ACCESS-TIMESTAMP': timestamp,
            'CB-ACCESS-PASSPHRASE': apiPassphrase,
            accept: 'json',
        },
    });
    if (oracleDataRaw.statusCode != 200) {
        throw new Error(`Failed to retrieve oracle data!\n${oracleDataRaw.statusCode}: ${oracleDataRaw.content}`);
    }
    const oracleData = JSON.parse(oracleDataRaw.content);
    return parseRawOracleData(oracleData);
}
function parseRawOracleData(oracleData) {
    const result = {
        messages: oracleData.messages.map((message) => {
            const parsed = conseiljs_1.TezosLanguageUtil.hexToMichelson(message.slice(2));
            const normalized = conseiljs_1.TezosLanguageUtil.normalizeMichelsonWhiteSpace(parsed.code);
            return normalized;
        }),
        signatures: oracleData.signatures,
    };
    return result;
}
function listElementForAsset(oracleData, assetName) {
    for (let i = 0; i < oracleData.messages.length; i++) {
        const message = oracleData.messages[i];
        if (message.includes(assetName)) {
            const signature = oracleData.signatures[i];
            const startSlice = `(Pair "${assetName}" `;
            const messageWithoutAssetName = message.slice(startSlice.length, message.length - 1);
            const reformatted = `Elt '${assetName}'(Pair '${signature}' ${messageWithoutAssetName})`;
            return reformatted;
        }
    }
    throw new Error(`Could not locate ${assetName} in ${JSON.stringify(oracleData.messages)}`);
}
//# sourceMappingURL=update.js.map