parameter (or (or (or (unit %default) (unit %makeOven)) (or (nat %makeOven_minterCallback) (address %setGovernorContract))) (or (or (option %setInitialDelegate key_hash) (address %setMinterContract)) (or (address %setOvenProxyContract) (address %setOvenRegistryContract))));
storage   (pair (pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))));
code
  {
    UNPAIR;     # @parameter : @storage
    IF_LEFT
      {
        IF_LEFT
          {
            IF_LEFT
              {
                PUSH int 19; # int : @parameter%default : @storage
                FAILWITH;   # FAILED
              }
              {
                DROP;       # @storage
                # == makeOven ==
                # sp.verify(self.data.state == 0, 12) # @storage
                DUP;        # @storage : @storage
                GET 6;      # int : @storage
                PUSH int 0; # int : int : @storage
                COMPARE;    # int : @storage
                EQ;         # bool : @storage
                IF
                  {}
                  {
                    PUSH int 12; # int : @storage
                    FAILWITH;   # FAILED
                  }; # @storage
                # sp.verify(sp.amount == sp.tez(0), 15) # @storage
                PUSH mutez 0; # mutez : @storage
                AMOUNT;     # @amount : mutez : @storage
                COMPARE;    # int : @storage
                EQ;         # bool : @storage
                IF
                  {}
                  {
                    PUSH int 15; # int : @storage
                    FAILWITH;   # FAILED
                  }; # @storage
                # self.data.state = 1 # @storage
                PUSH int 1; # int : @storage
                UPDATE 6;   # @storage
                # self.data.makeOvenOwner = sp.some(sp.sender) # @storage
                UNPAIR;     # pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))
                UNPAIR;     # address : pair (option %initialDelegate key_hash) (option %makeOvenOwner address) : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))
                SWAP;       # pair (option %initialDelegate key_hash) (option %makeOvenOwner address) : address : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))
                CAR;        # option key_hash : address : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))
                SENDER;     # @sender : option key_hash : address : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))
                SOME;       # option address : option key_hash : address : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))
                SWAP;       # option key_hash : option address : address : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))
                PAIR;       # pair (option key_hash) (option address) : address : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))
                SWAP;       # address : pair (option key_hash) (option address) : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))
                PAIR;       # pair address (pair (option key_hash) (option address)) : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))
                PAIR;       # pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
                # sp.transfer(sp.self_entry_point('makeOven_minterCallback'), sp.tez(0), sp.contract(sp.TContract(sp.TNat), self.data.minterContractAddress, entry_point='getInterestIndex').open_some()) # pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
                DUP;        # pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))) : pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
                GET 3;      # pair (address %minterContractAddress) (address %ovenProxyContractAddress) : pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
                CAR;        # address : pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
                CONTRACT %getInterestIndex (contract nat); # option (contract (contract nat)) : pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
                IF_NONE
                  {
                    UNIT;       # unit : pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
                    FAILWITH;   # FAILED
                  }
                  {}; # @some : pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
                NIL operation; # list operation : @some : pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
                SWAP;       # @some : list operation : pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
                PUSH mutez 0; # mutez : @some : list operation : pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
                SELF %makeOven_minterCallback; # @self : mutez : @some : list operation : pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
                TRANSFER_TOKENS; # operation : list operation : pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
                CONS;       # list operation : pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
              }; # list operation : pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
          }
          {
            IF_LEFT
              {
                SWAP;       # @storage : @parameter%makeOven_minterCallback
                # == makeOven_minterCallback ==
                # sp.verify(sp.sender == self.data.minterContractAddress, 5) # @storage : @parameter%makeOven_minterCallback
                DUP;        # @storage : @storage : @parameter%makeOven_minterCallback
                DUG 2;      # @storage : @parameter%makeOven_minterCallback : @storage
                GET 3;      # pair (address %minterContractAddress) (address %ovenProxyContractAddress) : @parameter%makeOven_minterCallback : @storage
                CAR;        # address : @parameter%makeOven_minterCallback : @storage
                SENDER;     # @sender : address : @parameter%makeOven_minterCallback : @storage
                COMPARE;    # int : @parameter%makeOven_minterCallback : @storage
                EQ;         # bool : @parameter%makeOven_minterCallback : @storage
                IF
                  {}
                  {
                    PUSH int 5; # int : @parameter%makeOven_minterCallback : @storage
                    FAILWITH;   # FAILED
                  }; # @parameter%makeOven_minterCallback : @storage
                # sp.verify(self.data.state == 1, 12) # @parameter%makeOven_minterCallback : @storage
                PUSH int 1; # int : @parameter%makeOven_minterCallback : @storage
                DUP 3;      # @storage : int : @parameter%makeOven_minterCallback : @storage
                GET 6;      # int : int : @parameter%makeOven_minterCallback : @storage
                COMPARE;    # int : @parameter%makeOven_minterCallback : @storage
                EQ;         # bool : @parameter%makeOven_minterCallback : @storage
                IF
                  {}
                  {
                    PUSH int 12; # int : @parameter%makeOven_minterCallback : @storage
                    FAILWITH;   # FAILED
                  }; # @parameter%makeOven_minterCallback : @storage
                # create_contract_oven-factory_102 = sp.local("create_contract_oven-factory_102", create contract ...) # @parameter%makeOven_minterCallback : @storage
                NIL operation; # list operation : @parameter%makeOven_minterCallback : @storage
                PUSH int 0; # int : list operation : @parameter%makeOven_minterCallback : @storage
                DUP 4;      # @storage : int : list operation : @parameter%makeOven_minterCallback : @storage
                CAR;        # pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : int : list operation : @parameter%makeOven_minterCallback : @storage
                GET 4;      # option address : int : list operation : @parameter%makeOven_minterCallback : @storage
                IF_NONE
                  {
                    UNIT;       # unit : int : list operation : @parameter%makeOven_minterCallback : @storage
                    FAILWITH;   # FAILED
                  }
                  {}; # @some : int : list operation : @parameter%makeOven_minterCallback : @storage
                PAIR;       # pair @some int : list operation : @parameter%makeOven_minterCallback : @storage
                DUP 4;      # @storage : pair @some int : list operation : @parameter%makeOven_minterCallback : @storage
                GET 3;      # pair (address %minterContractAddress) (address %ovenProxyContractAddress) : pair @some int : list operation : @parameter%makeOven_minterCallback : @storage
                CDR;        # address : pair @some int : list operation : @parameter%makeOven_minterCallback : @storage
                PAIR;       # pair address (pair @some int) : list operation : @parameter%makeOven_minterCallback : @storage
                PUSH bool False; # bool : pair address (pair @some int) : list operation : @parameter%makeOven_minterCallback : @storage
                DIG 3;      # @parameter%makeOven_minterCallback : bool : pair address (pair @some int) : list operation : @storage
                INT;        # int : bool : pair address (pair @some int) : list operation : @storage
                PAIR;       # pair int bool : pair address (pair @some int) : list operation : @storage
                PUSH nat 0; # nat : pair int bool : pair address (pair @some int) : list operation : @storage
                PAIR;       # pair nat (pair int bool) : pair address (pair @some int) : list operation : @storage
                PAIR;       # pair (pair nat (pair int bool)) (pair address (pair @some int)) : list operation : @storage
                PUSH mutez 0; # mutez : pair (pair nat (pair int bool)) (pair address (pair @some int)) : list operation : @storage
                DUP 4;      # @storage : mutez : pair (pair nat (pair int bool)) (pair address (pair @some int)) : list operation : @storage
                CAR;        # pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : mutez : pair (pair nat (pair int bool)) (pair address (pair @some int)) : list operation : @storage
                GET 3;      # option key_hash : mutez : pair (pair nat (pair int bool)) (pair address (pair @some int)) : list operation : @storage
                CREATE_CONTRACT
                 { parameter (or (or (nat %borrow) (or (unit %default) (unit %liquidate))) (or (or (nat %repay) (option %setDelegate key_hash)) (or (pair %updateState address (pair nat (pair int (pair int bool)))) (mutez %withdraw))));
                   storage   (pair (pair (nat %borrowedTokens) (pair (int %interestIndex) (bool %isLiquidated))) (pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens))));
                   code
                     {
                       UNPAIR;     # @parameter : @storage
                       IF_LEFT
                         {
                           IF_LEFT
                             {
                               SWAP;       # @storage : @parameter%borrow
                               # == borrow ==
                               # sp.verify(sp.sender == self.data.owner, 6) # @storage : @parameter%borrow
                               DUP;        # @storage : @storage : @parameter%borrow
                               DUG 2;      # @storage : @parameter%borrow : @storage
                               GET 5;      # address : @parameter%borrow : @storage
                               SENDER;     # @sender : address : @parameter%borrow : @storage
                               COMPARE;    # int : @parameter%borrow : @storage
                               EQ;         # bool : @parameter%borrow : @storage
                               IF
                                 {}
                                 {
                                   PUSH int 6; # int : @parameter%borrow : @storage
                                   FAILWITH;   # FAILED
                                 }; # @parameter%borrow : @storage
                               # sp.verify(sp.amount == sp.tez(0), 15) # @parameter%borrow : @storage
                               PUSH mutez 0; # mutez : @parameter%borrow : @storage
                               AMOUNT;     # @amount : mutez : @parameter%borrow : @storage
                               COMPARE;    # int : @parameter%borrow : @storage
                               EQ;         # bool : @parameter%borrow : @storage
                               IF
                                 {}
                                 {
                                   PUSH int 15; # int : @parameter%borrow : @storage
                                   FAILWITH;   # FAILED
                                 }; # @parameter%borrow : @storage
                               # sp.transfer((sp.self_address, (self.data.owner, (sp.fst(sp.ediv(sp.balance, sp.mutez(1)).open_some()) * 1000000000000, (self.data.borrowedTokens, (self.data.isLiquidated, (self.data.stabilityFeeTokens, (self.data.interestIndex, params))))))), sp.balance, sp.contract(sp.TPair(sp.TAddress, sp.TPair(sp.TAddress, sp.TPair(sp.TNat, sp.TPair(sp.TNat, sp.TPair(sp.TBool, sp.TPair(sp.TInt, sp.TPair(sp.TInt, sp.TNat))))))), self.data.ovenProxyContractAddress, entry_point='borrow').open_some()) # @parameter%borrow : @storage
                               NIL operation; # list operation : @parameter%borrow : @storage
                               DUP 3;      # @storage : list operation : @parameter%borrow : @storage
                               GET 3;      # address : list operation : @parameter%borrow : @storage
                               CONTRACT %borrow (pair address (pair address (pair nat (pair nat (pair bool (pair int (pair int nat))))))); # option (contract (pair address (pair address (pair nat (pair nat (pair bool (pair int (pair int nat)))))))) : list operation : @parameter%borrow : @storage
                               IF_NONE
                                 {
                                   UNIT;       # unit : list operation : @parameter%borrow : @storage
                                   FAILWITH;   # FAILED
                                 }
                                 {}; # @some : list operation : @parameter%borrow : @storage
                               BALANCE;    # @balance : @some : list operation : @parameter%borrow : @storage
                               DIG 3;      # @parameter%borrow : @balance : @some : list operation : @storage
                               DUP 5;      # @storage : @parameter%borrow : @balance : @some : list operation : @storage
                               CAR;        # pair (nat %borrowedTokens) (pair (int %interestIndex) (bool %isLiquidated)) : @parameter%borrow : @balance : @some : list operation : @storage
                               GET 3;      # int : @parameter%borrow : @balance : @some : list operation : @storage
                               PAIR;       # pair int @parameter%borrow : @balance : @some : list operation : @storage
                               DUP 5;      # @storage : pair int @parameter%borrow : @balance : @some : list operation : @storage
                               GET 6;      # int : pair int @parameter%borrow : @balance : @some : list operation : @storage
                               PAIR;       # pair int (pair int @parameter%borrow) : @balance : @some : list operation : @storage
                               DUP 5;      # @storage : pair int (pair int @parameter%borrow) : @balance : @some : list operation : @storage
                               CAR;        # pair (nat %borrowedTokens) (pair (int %interestIndex) (bool %isLiquidated)) : pair int (pair int @parameter%borrow) : @balance : @some : list operation : @storage
                               GET 4;      # bool : pair int (pair int @parameter%borrow) : @balance : @some : list operation : @storage
                               PAIR;       # pair bool (pair int (pair int @parameter%borrow)) : @balance : @some : list operation : @storage
                               DUP 5;      # @storage : pair bool (pair int (pair int @parameter%borrow)) : @balance : @some : list operation : @storage
                               CAR;        # pair (nat %borrowedTokens) (pair (int %interestIndex) (bool %isLiquidated)) : pair bool (pair int (pair int @parameter%borrow)) : @balance : @some : list operation : @storage
                               CAR;        # nat : pair bool (pair int (pair int @parameter%borrow)) : @balance : @some : list operation : @storage
                               PAIR;       # pair nat (pair bool (pair int (pair int @parameter%borrow))) : @balance : @some : list operation : @storage
                               PUSH nat 1000000000000; # nat : pair nat (pair bool (pair int (pair int @parameter%borrow))) : @balance : @some : list operation : @storage
                               PUSH mutez 1; # mutez : nat : pair nat (pair bool (pair int (pair int @parameter%borrow))) : @balance : @some : list operation : @storage
                               BALANCE;    # @balance : mutez : nat : pair nat (pair bool (pair int (pair int @parameter%borrow))) : @balance : @some : list operation : @storage
                               EDIV;       # option (pair nat mutez) : nat : pair nat (pair bool (pair int (pair int @parameter%borrow))) : @balance : @some : list operation : @storage
                               IF_NONE
                                 {
                                   UNIT;       # unit : nat : pair nat (pair bool (pair int (pair int @parameter%borrow))) : @balance : @some : list operation : @storage
                                   FAILWITH;   # FAILED
                                 }
                                 {}; # @some : nat : pair nat (pair bool (pair int (pair int @parameter%borrow))) : @balance : @some : list operation : @storage
                               CAR;        # nat : nat : pair nat (pair bool (pair int (pair int @parameter%borrow))) : @balance : @some : list operation : @storage
                               MUL;        # nat : pair nat (pair bool (pair int (pair int @parameter%borrow))) : @balance : @some : list operation : @storage
                               PAIR;       # pair nat (pair nat (pair bool (pair int (pair int @parameter%borrow)))) : @balance : @some : list operation : @storage
                               DUP 5;      # @storage : pair nat (pair nat (pair bool (pair int (pair int @parameter%borrow)))) : @balance : @some : list operation : @storage
                               GET 5;      # address : pair nat (pair nat (pair bool (pair int (pair int @parameter%borrow)))) : @balance : @some : list operation : @storage
                               PAIR;       # pair address (pair nat (pair nat (pair bool (pair int (pair int @parameter%borrow))))) : @balance : @some : list operation : @storage
                               SELF_ADDRESS; # @self : pair address (pair nat (pair nat (pair bool (pair int (pair int @parameter%borrow))))) : @balance : @some : list operation : @storage
                               PAIR;       # pair @self (pair address (pair nat (pair nat (pair bool (pair int (pair int @parameter%borrow)))))) : @balance : @some : list operation : @storage
                               TRANSFER_TOKENS; # operation : list operation : @storage
                               CONS;       # list operation : @storage
                             }
                             {
                               IF_LEFT
                                 {
                                   DROP;       # @storage
                                   # == default ==
                                   # sp.transfer((sp.self_address, (self.data.owner, (sp.fst(sp.ediv(sp.balance, sp.mutez(1)).open_some()) * 1000000000000, (self.data.borrowedTokens, (self.data.isLiquidated, (self.data.stabilityFeeTokens, self.data.interestIndex)))))), sp.balance, sp.contract(sp.TPair(sp.TAddress, sp.TPair(sp.TAddress, sp.TPair(sp.TNat, sp.TPair(sp.TNat, sp.TPair(sp.TBool, sp.TPair(sp.TInt, sp.TInt)))))), self.data.ovenProxyContractAddress, entry_point='deposit').open_some()) # @storage
                                   DUP;        # @storage : @storage
                                   GET 3;      # address : @storage
                                   CONTRACT %deposit (pair address (pair address (pair nat (pair nat (pair bool (pair int int)))))); # option (contract (pair address (pair address (pair nat (pair nat (pair bool (pair int int))))))) : @storage
                                   IF_NONE
                                     {
                                       UNIT;       # unit : @storage
                                       FAILWITH;   # FAILED
                                     }
                                     {}; # @some : @storage
                                   NIL operation; # list operation : @some : @storage
                                   SWAP;       # @some : list operation : @storage
                                   BALANCE;    # @balance : @some : list operation : @storage
                                   DIG 3;      # @storage : @balance : @some : list operation
                                   DUP;        # @storage : @storage : @balance : @some : list operation
                                   CAR;        # pair (nat %borrowedTokens) (pair (int %interestIndex) (bool %isLiquidated)) : @storage : @balance : @some : list operation
                                   GET 3;      # int : @storage : @balance : @some : list operation
                                   SWAP;       # @storage : int : @balance : @some : list operation
                                   DUP;        # @storage : @storage : int : @balance : @some : list operation
                                   DUG 5;      # @storage : int : @balance : @some : list operation : @storage
                                   GET 6;      # int : int : @balance : @some : list operation : @storage
                                   PAIR;       # pair int int : @balance : @some : list operation : @storage
                                   DUP 5;      # @storage : pair int int : @balance : @some : list operation : @storage
                                   CAR;        # pair (nat %borrowedTokens) (pair (int %interestIndex) (bool %isLiquidated)) : pair int int : @balance : @some : list operation : @storage
                                   GET 4;      # bool : pair int int : @balance : @some : list operation : @storage
                                   PAIR;       # pair bool (pair int int) : @balance : @some : list operation : @storage
                                   DUP 5;      # @storage : pair bool (pair int int) : @balance : @some : list operation : @storage
                                   CAR;        # pair (nat %borrowedTokens) (pair (int %interestIndex) (bool %isLiquidated)) : pair bool (pair int int) : @balance : @some : list operation : @storage
                                   CAR;        # nat : pair bool (pair int int) : @balance : @some : list operation : @storage
                                   PAIR;       # pair nat (pair bool (pair int int)) : @balance : @some : list operation : @storage
                                   PUSH nat 1000000000000; # nat : pair nat (pair bool (pair int int)) : @balance : @some : list operation : @storage
                                   PUSH mutez 1; # mutez : nat : pair nat (pair bool (pair int int)) : @balance : @some : list operation : @storage
                                   BALANCE;    # @balance : mutez : nat : pair nat (pair bool (pair int int)) : @balance : @some : list operation : @storage
                                   EDIV;       # option (pair nat mutez) : nat : pair nat (pair bool (pair int int)) : @balance : @some : list operation : @storage
                                   IF_NONE
                                     {
                                       UNIT;       # unit : nat : pair nat (pair bool (pair int int)) : @balance : @some : list operation : @storage
                                       FAILWITH;   # FAILED
                                     }
                                     {}; # @some : nat : pair nat (pair bool (pair int int)) : @balance : @some : list operation : @storage
                                   CAR;        # nat : nat : pair nat (pair bool (pair int int)) : @balance : @some : list operation : @storage
                                   MUL;        # nat : pair nat (pair bool (pair int int)) : @balance : @some : list operation : @storage
                                   PAIR;       # pair nat (pair nat (pair bool (pair int int))) : @balance : @some : list operation : @storage
                                   DUP 5;      # @storage : pair nat (pair nat (pair bool (pair int int))) : @balance : @some : list operation : @storage
                                   GET 5;      # address : pair nat (pair nat (pair bool (pair int int))) : @balance : @some : list operation : @storage
                                   PAIR;       # pair address (pair nat (pair nat (pair bool (pair int int)))) : @balance : @some : list operation : @storage
                                   SELF_ADDRESS; # @self : pair address (pair nat (pair nat (pair bool (pair int int)))) : @balance : @some : list operation : @storage
                                   PAIR;       # pair @self (pair address (pair nat (pair nat (pair bool (pair int int))))) : @balance : @some : list operation : @storage
                                   TRANSFER_TOKENS; # operation : list operation : @storage
                                   CONS;       # list operation : @storage
                                 }
                                 {
                                   DROP;       # @storage
                                   # == liquidate ==
                                   # sp.verify(sp.amount == sp.tez(0), 15) # @storage
                                   PUSH mutez 0; # mutez : @storage
                                   AMOUNT;     # @amount : mutez : @storage
                                   COMPARE;    # int : @storage
                                   EQ;         # bool : @storage
                                   IF
                                     {}
                                     {
                                       PUSH int 15; # int : @storage
                                       FAILWITH;   # FAILED
                                     }; # @storage
                                   # sp.transfer((sp.self_address, (self.data.owner, (sp.fst(sp.ediv(sp.balance, sp.mutez(1)).open_some()) * 1000000000000, (self.data.borrowedTokens, (self.data.isLiquidated, (self.data.stabilityFeeTokens, (self.data.interestIndex, sp.sender))))))), sp.balance, sp.contract(sp.TPair(sp.TAddress, sp.TPair(sp.TAddress, sp.TPair(sp.TNat, sp.TPair(sp.TNat, sp.TPair(sp.TBool, sp.TPair(sp.TInt, sp.TPair(sp.TInt, sp.TAddress))))))), self.data.ovenProxyContractAddress, entry_point='liquidate').open_some()) # @storage
                                   DUP;        # @storage : @storage
                                   GET 3;      # address : @storage
                                   CONTRACT %liquidate (pair address (pair address (pair nat (pair nat (pair bool (pair int (pair int address))))))); # option (contract (pair address (pair address (pair nat (pair nat (pair bool (pair int (pair int address)))))))) : @storage
                                   IF_NONE
                                     {
                                       UNIT;       # unit : @storage
                                       FAILWITH;   # FAILED
                                     }
                                     {}; # @some : @storage
                                   NIL operation; # list operation : @some : @storage
                                   SWAP;       # @some : list operation : @storage
                                   BALANCE;    # @balance : @some : list operation : @storage
                                   SENDER;     # @sender : @balance : @some : list operation : @storage
                                   DUP 5;      # @storage : @sender : @balance : @some : list operation : @storage
                                   CAR;        # pair (nat %borrowedTokens) (pair (int %interestIndex) (bool %isLiquidated)) : @sender : @balance : @some : list operation : @storage
                                   GET 3;      # int : @sender : @balance : @some : list operation : @storage
                                   PAIR;       # pair int @sender : @balance : @some : list operation : @storage
                                   DUP 5;      # @storage : pair int @sender : @balance : @some : list operation : @storage
                                   GET 6;      # int : pair int @sender : @balance : @some : list operation : @storage
                                   PAIR;       # pair int (pair int @sender) : @balance : @some : list operation : @storage
                                   DUP 5;      # @storage : pair int (pair int @sender) : @balance : @some : list operation : @storage
                                   CAR;        # pair (nat %borrowedTokens) (pair (int %interestIndex) (bool %isLiquidated)) : pair int (pair int @sender) : @balance : @some : list operation : @storage
                                   GET 4;      # bool : pair int (pair int @sender) : @balance : @some : list operation : @storage
                                   PAIR;       # pair bool (pair int (pair int @sender)) : @balance : @some : list operation : @storage
                                   DUP 5;      # @storage : pair bool (pair int (pair int @sender)) : @balance : @some : list operation : @storage
                                   CAR;        # pair (nat %borrowedTokens) (pair (int %interestIndex) (bool %isLiquidated)) : pair bool (pair int (pair int @sender)) : @balance : @some : list operation : @storage
                                   CAR;        # nat : pair bool (pair int (pair int @sender)) : @balance : @some : list operation : @storage
                                   PAIR;       # pair nat (pair bool (pair int (pair int @sender))) : @balance : @some : list operation : @storage
                                   PUSH nat 1000000000000; # nat : pair nat (pair bool (pair int (pair int @sender))) : @balance : @some : list operation : @storage
                                   PUSH mutez 1; # mutez : nat : pair nat (pair bool (pair int (pair int @sender))) : @balance : @some : list operation : @storage
                                   BALANCE;    # @balance : mutez : nat : pair nat (pair bool (pair int (pair int @sender))) : @balance : @some : list operation : @storage
                                   EDIV;       # option (pair nat mutez) : nat : pair nat (pair bool (pair int (pair int @sender))) : @balance : @some : list operation : @storage
                                   IF_NONE
                                     {
                                       UNIT;       # unit : nat : pair nat (pair bool (pair int (pair int @sender))) : @balance : @some : list operation : @storage
                                       FAILWITH;   # FAILED
                                     }
                                     {}; # @some : nat : pair nat (pair bool (pair int (pair int @sender))) : @balance : @some : list operation : @storage
                                   CAR;        # nat : nat : pair nat (pair bool (pair int (pair int @sender))) : @balance : @some : list operation : @storage
                                   MUL;        # nat : pair nat (pair bool (pair int (pair int @sender))) : @balance : @some : list operation : @storage
                                   PAIR;       # pair nat (pair nat (pair bool (pair int (pair int @sender)))) : @balance : @some : list operation : @storage
                                   DUP 5;      # @storage : pair nat (pair nat (pair bool (pair int (pair int @sender)))) : @balance : @some : list operation : @storage
                                   GET 5;      # address : pair nat (pair nat (pair bool (pair int (pair int @sender)))) : @balance : @some : list operation : @storage
                                   PAIR;       # pair address (pair nat (pair nat (pair bool (pair int (pair int @sender))))) : @balance : @some : list operation : @storage
                                   SELF_ADDRESS; # @self : pair address (pair nat (pair nat (pair bool (pair int (pair int @sender))))) : @balance : @some : list operation : @storage
                                   PAIR;       # pair @self (pair address (pair nat (pair nat (pair bool (pair int (pair int @sender)))))) : @balance : @some : list operation : @storage
                                   TRANSFER_TOKENS; # operation : list operation : @storage
                                   CONS;       # list operation : @storage
                                 }; # list operation : @storage
                             }; # list operation : @storage
                         }
                         {
                           IF_LEFT
                             {
                               IF_LEFT
                                 {
                                   SWAP;       # @storage : @parameter%repay
                                   # == repay ==
                                   # sp.verify(sp.sender == self.data.owner, 6) # @storage : @parameter%repay
                                   DUP;        # @storage : @storage : @parameter%repay
                                   DUG 2;      # @storage : @parameter%repay : @storage
                                   GET 5;      # address : @parameter%repay : @storage
                                   SENDER;     # @sender : address : @parameter%repay : @storage
                                   COMPARE;    # int : @parameter%repay : @storage
                                   EQ;         # bool : @parameter%repay : @storage
                                   IF
                                     {}
                                     {
                                       PUSH int 6; # int : @parameter%repay : @storage
                                       FAILWITH;   # FAILED
                                     }; # @parameter%repay : @storage
                                   # sp.verify(sp.amount == sp.tez(0), 15) # @parameter%repay : @storage
                                   PUSH mutez 0; # mutez : @parameter%repay : @storage
                                   AMOUNT;     # @amount : mutez : @parameter%repay : @storage
                                   COMPARE;    # int : @parameter%repay : @storage
                                   EQ;         # bool : @parameter%repay : @storage
                                   IF
                                     {}
                                     {
                                       PUSH int 15; # int : @parameter%repay : @storage
                                       FAILWITH;   # FAILED
                                     }; # @parameter%repay : @storage
                                   # sp.transfer((sp.self_address, (self.data.owner, (sp.fst(sp.ediv(sp.balance, sp.mutez(1)).open_some()) * 1000000000000, (self.data.borrowedTokens, (self.data.isLiquidated, (self.data.stabilityFeeTokens, (self.data.interestIndex, params))))))), sp.balance, sp.contract(sp.TPair(sp.TAddress, sp.TPair(sp.TAddress, sp.TPair(sp.TNat, sp.TPair(sp.TNat, sp.TPair(sp.TBool, sp.TPair(sp.TInt, sp.TPair(sp.TInt, sp.TNat))))))), self.data.ovenProxyContractAddress, entry_point='repay').open_some()) # @parameter%repay : @storage
                                   NIL operation; # list operation : @parameter%repay : @storage
                                   DUP 3;      # @storage : list operation : @parameter%repay : @storage
                                   GET 3;      # address : list operation : @parameter%repay : @storage
                                   CONTRACT %repay (pair address (pair address (pair nat (pair nat (pair bool (pair int (pair int nat))))))); # option (contract (pair address (pair address (pair nat (pair nat (pair bool (pair int (pair int nat)))))))) : list operation : @parameter%repay : @storage
                                   IF_NONE
                                     {
                                       UNIT;       # unit : list operation : @parameter%repay : @storage
                                       FAILWITH;   # FAILED
                                     }
                                     {}; # @some : list operation : @parameter%repay : @storage
                                   BALANCE;    # @balance : @some : list operation : @parameter%repay : @storage
                                   DIG 3;      # @parameter%repay : @balance : @some : list operation : @storage
                                   DUP 5;      # @storage : @parameter%repay : @balance : @some : list operation : @storage
                                   CAR;        # pair (nat %borrowedTokens) (pair (int %interestIndex) (bool %isLiquidated)) : @parameter%repay : @balance : @some : list operation : @storage
                                   GET 3;      # int : @parameter%repay : @balance : @some : list operation : @storage
                                   PAIR;       # pair int @parameter%repay : @balance : @some : list operation : @storage
                                   DUP 5;      # @storage : pair int @parameter%repay : @balance : @some : list operation : @storage
                                   GET 6;      # int : pair int @parameter%repay : @balance : @some : list operation : @storage
                                   PAIR;       # pair int (pair int @parameter%repay) : @balance : @some : list operation : @storage
                                   DUP 5;      # @storage : pair int (pair int @parameter%repay) : @balance : @some : list operation : @storage
                                   CAR;        # pair (nat %borrowedTokens) (pair (int %interestIndex) (bool %isLiquidated)) : pair int (pair int @parameter%repay) : @balance : @some : list operation : @storage
                                   GET 4;      # bool : pair int (pair int @parameter%repay) : @balance : @some : list operation : @storage
                                   PAIR;       # pair bool (pair int (pair int @parameter%repay)) : @balance : @some : list operation : @storage
                                   DUP 5;      # @storage : pair bool (pair int (pair int @parameter%repay)) : @balance : @some : list operation : @storage
                                   CAR;        # pair (nat %borrowedTokens) (pair (int %interestIndex) (bool %isLiquidated)) : pair bool (pair int (pair int @parameter%repay)) : @balance : @some : list operation : @storage
                                   CAR;        # nat : pair bool (pair int (pair int @parameter%repay)) : @balance : @some : list operation : @storage
                                   PAIR;       # pair nat (pair bool (pair int (pair int @parameter%repay))) : @balance : @some : list operation : @storage
                                   PUSH nat 1000000000000; # nat : pair nat (pair bool (pair int (pair int @parameter%repay))) : @balance : @some : list operation : @storage
                                   PUSH mutez 1; # mutez : nat : pair nat (pair bool (pair int (pair int @parameter%repay))) : @balance : @some : list operation : @storage
                                   BALANCE;    # @balance : mutez : nat : pair nat (pair bool (pair int (pair int @parameter%repay))) : @balance : @some : list operation : @storage
                                   EDIV;       # option (pair nat mutez) : nat : pair nat (pair bool (pair int (pair int @parameter%repay))) : @balance : @some : list operation : @storage
                                   IF_NONE
                                     {
                                       UNIT;       # unit : nat : pair nat (pair bool (pair int (pair int @parameter%repay))) : @balance : @some : list operation : @storage
                                       FAILWITH;   # FAILED
                                     }
                                     {}; # @some : nat : pair nat (pair bool (pair int (pair int @parameter%repay))) : @balance : @some : list operation : @storage
                                   CAR;        # nat : nat : pair nat (pair bool (pair int (pair int @parameter%repay))) : @balance : @some : list operation : @storage
                                   MUL;        # nat : pair nat (pair bool (pair int (pair int @parameter%repay))) : @balance : @some : list operation : @storage
                                   PAIR;       # pair nat (pair nat (pair bool (pair int (pair int @parameter%repay)))) : @balance : @some : list operation : @storage
                                   DUP 5;      # @storage : pair nat (pair nat (pair bool (pair int (pair int @parameter%repay)))) : @balance : @some : list operation : @storage
                                   GET 5;      # address : pair nat (pair nat (pair bool (pair int (pair int @parameter%repay)))) : @balance : @some : list operation : @storage
                                   PAIR;       # pair address (pair nat (pair nat (pair bool (pair int (pair int @parameter%repay))))) : @balance : @some : list operation : @storage
                                   SELF_ADDRESS; # @self : pair address (pair nat (pair nat (pair bool (pair int (pair int @parameter%repay))))) : @balance : @some : list operation : @storage
                                   PAIR;       # pair @self (pair address (pair nat (pair nat (pair bool (pair int (pair int @parameter%repay)))))) : @balance : @some : list operation : @storage
                                   TRANSFER_TOKENS; # operation : list operation : @storage
                                   CONS;       # list operation : @storage
                                 }
                                 {
                                   SWAP;       # @storage : @parameter%setDelegate
                                   # == setDelegate ==
                                   # sp.verify(sp.sender == self.data.owner, 6) # @storage : @parameter%setDelegate
                                   DUP;        # @storage : @storage : @parameter%setDelegate
                                   DUG 2;      # @storage : @parameter%setDelegate : @storage
                                   GET 5;      # address : @parameter%setDelegate : @storage
                                   SENDER;     # @sender : address : @parameter%setDelegate : @storage
                                   COMPARE;    # int : @parameter%setDelegate : @storage
                                   EQ;         # bool : @parameter%setDelegate : @storage
                                   IF
                                     {}
                                     {
                                       PUSH int 6; # int : @parameter%setDelegate : @storage
                                       FAILWITH;   # FAILED
                                     }; # @parameter%setDelegate : @storage
                                   # sp.verify(sp.amount == sp.tez(0), 15) # @parameter%setDelegate : @storage
                                   PUSH mutez 0; # mutez : @parameter%setDelegate : @storage
                                   AMOUNT;     # @amount : mutez : @parameter%setDelegate : @storage
                                   COMPARE;    # int : @parameter%setDelegate : @storage
                                   EQ;         # bool : @parameter%setDelegate : @storage
                                   IF
                                     {}
                                     {
                                       PUSH int 15; # int : @parameter%setDelegate : @storage
                                       FAILWITH;   # FAILED
                                     }; # @parameter%setDelegate : @storage
                                   # sp.set_delegate(params) # @parameter%setDelegate : @storage
                                   SET_DELEGATE; # operation : @storage
                                   NIL operation; # list operation : operation : @storage
                                   SWAP;       # operation : list operation : @storage
                                   CONS;       # list operation : @storage
                                 }; # list operation : @storage
                             }
                             {
                               IF_LEFT
                                 {
                                   SWAP;       # @storage : @parameter%updateState
                                   # == updateState ==
                                   # sp.verify(sp.sender == self.data.ovenProxyContractAddress, 2) # @storage : @parameter%updateState
                                   DUP;        # @storage : @storage : @parameter%updateState
                                   DUG 2;      # @storage : @parameter%updateState : @storage
                                   GET 3;      # address : @parameter%updateState : @storage
                                   SENDER;     # @sender : address : @parameter%updateState : @storage
                                   COMPARE;    # int : @parameter%updateState : @storage
                                   EQ;         # bool : @parameter%updateState : @storage
                                   IF
                                     {}
                                     {
                                       PUSH int 2; # int : @parameter%updateState : @storage
                                       FAILWITH;   # FAILED
                                     }; # @parameter%updateState : @storage
                                   # sp.verify(sp.fst(params) == sp.self_address, 13) # @parameter%updateState : @storage
                                   DUP;        # @parameter%updateState : @parameter%updateState : @storage
                                   CAR;        # address : @parameter%updateState : @storage
                                   SELF_ADDRESS; # @self : address : @parameter%updateState : @storage
                                   COMPARE;    # int : @parameter%updateState : @storage
                                   EQ;         # bool : @parameter%updateState : @storage
                                   IF
                                     {}
                                     {
                                       PUSH int 13; # int : @parameter%updateState : @storage
                                       FAILWITH;   # FAILED
                                     }; # @parameter%updateState : @storage
                                   SWAP;       # @storage : @parameter%updateState
                                   # self.data.borrowedTokens = sp.fst(sp.snd(params)) # @storage : @parameter%updateState
                                   UNPAIR;     # pair (nat %borrowedTokens) (pair (int %interestIndex) (bool %isLiquidated)) : pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens)) : @parameter%updateState
                                   CDR;        # pair (int %interestIndex) (bool %isLiquidated) : pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens)) : @parameter%updateState
                                   DUP 3;      # @parameter%updateState : pair (int %interestIndex) (bool %isLiquidated) : pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens)) : @parameter%updateState
                                   GET 3;      # nat : pair (int %interestIndex) (bool %isLiquidated) : pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens)) : @parameter%updateState
                                   PAIR;       # pair nat (pair (int %interestIndex) (bool %isLiquidated)) : pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens)) : @parameter%updateState
                                   PAIR;       # pair (pair nat (pair (int %interestIndex) (bool %isLiquidated))) (pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens))) : @parameter%updateState
                                   SWAP;       # @parameter%updateState : pair (pair nat (pair (int %interestIndex) (bool %isLiquidated))) (pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens)))
                                   # self.data.stabilityFeeTokens = sp.fst(sp.snd(sp.snd(params))) # @parameter%updateState : pair (pair nat (pair (int %interestIndex) (bool %isLiquidated))) (pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens)))
                                   DUP;        # @parameter%updateState : @parameter%updateState : pair (pair nat (pair (int %interestIndex) (bool %isLiquidated))) (pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens)))
                                   DUG 2;      # @parameter%updateState : pair (pair nat (pair (int %interestIndex) (bool %isLiquidated))) (pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens))) : @parameter%updateState
                                   GET 5;      # int : pair (pair nat (pair (int %interestIndex) (bool %isLiquidated))) (pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens))) : @parameter%updateState
                                   UPDATE 6;   # pair (pair nat (pair (int %interestIndex) (bool %isLiquidated))) (pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens))) : @parameter%updateState
                                   # self.data.interestIndex = sp.fst(sp.snd(sp.snd(sp.snd(params)))) # pair (pair nat (pair (int %interestIndex) (bool %isLiquidated))) (pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens))) : @parameter%updateState
                                   UNPAIR;     # pair nat (pair (int %interestIndex) (bool %isLiquidated)) : pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens)) : @parameter%updateState
                                   CAR;        # nat : pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens)) : @parameter%updateState
                                   DUP 3;      # @parameter%updateState : nat : pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens)) : @parameter%updateState
                                   GET 7;      # int : nat : pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens)) : @parameter%updateState
                                   # self.data.isLiquidated = sp.snd(sp.snd(sp.snd(sp.snd(params)))) # int : nat : pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens)) : @parameter%updateState
                                   DIG 3;      # @parameter%updateState : int : nat : pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens))
                                   GET 8;      # bool : int : nat : pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens))
                                   SWAP;       # int : bool : nat : pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens))
                                   PAIR;       # pair int bool : nat : pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens))
                                   SWAP;       # nat : pair int bool : pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens))
                                   PAIR;       # pair nat (pair int bool) : pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens))
                                   PAIR;       # pair (pair nat (pair int bool)) (pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens)))
                                   NIL operation; # list operation : pair (pair nat (pair int bool)) (pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens)))
                                 }
                                 {
                                   SWAP;       # @storage : @parameter%withdraw
                                   # == withdraw ==
                                   # sp.verify(sp.sender == self.data.owner, 6) # @storage : @parameter%withdraw
                                   DUP;        # @storage : @storage : @parameter%withdraw
                                   DUG 2;      # @storage : @parameter%withdraw : @storage
                                   GET 5;      # address : @parameter%withdraw : @storage
                                   SENDER;     # @sender : address : @parameter%withdraw : @storage
                                   COMPARE;    # int : @parameter%withdraw : @storage
                                   EQ;         # bool : @parameter%withdraw : @storage
                                   IF
                                     {}
                                     {
                                       PUSH int 6; # int : @parameter%withdraw : @storage
                                       FAILWITH;   # FAILED
                                     }; # @parameter%withdraw : @storage
                                   # sp.verify(sp.amount == sp.tez(0), 15) # @parameter%withdraw : @storage
                                   PUSH mutez 0; # mutez : @parameter%withdraw : @storage
                                   AMOUNT;     # @amount : mutez : @parameter%withdraw : @storage
                                   COMPARE;    # int : @parameter%withdraw : @storage
                                   EQ;         # bool : @parameter%withdraw : @storage
                                   IF
                                     {}
                                     {
                                       PUSH int 15; # int : @parameter%withdraw : @storage
                                       FAILWITH;   # FAILED
                                     }; # @parameter%withdraw : @storage
                                   # sp.transfer((sp.self_address, (self.data.owner, (sp.fst(sp.ediv(sp.balance, sp.mutez(1)).open_some()) * 1000000000000, (self.data.borrowedTokens, (self.data.isLiquidated, (self.data.stabilityFeeTokens, (self.data.interestIndex, params))))))), sp.balance, sp.contract(sp.TPair(sp.TAddress, sp.TPair(sp.TAddress, sp.TPair(sp.TNat, sp.TPair(sp.TNat, sp.TPair(sp.TBool, sp.TPair(sp.TInt, sp.TPair(sp.TInt, sp.TMutez))))))), self.data.ovenProxyContractAddress, entry_point='withdraw').open_some()) # @parameter%withdraw : @storage
                                   NIL operation; # list operation : @parameter%withdraw : @storage
                                   DUP 3;      # @storage : list operation : @parameter%withdraw : @storage
                                   GET 3;      # address : list operation : @parameter%withdraw : @storage
                                   CONTRACT %withdraw (pair address (pair address (pair nat (pair nat (pair bool (pair int (pair int mutez))))))); # option (contract (pair address (pair address (pair nat (pair nat (pair bool (pair int (pair int mutez)))))))) : list operation : @parameter%withdraw : @storage
                                   IF_NONE
                                     {
                                       UNIT;       # unit : list operation : @parameter%withdraw : @storage
                                       FAILWITH;   # FAILED
                                     }
                                     {}; # @some : list operation : @parameter%withdraw : @storage
                                   BALANCE;    # @balance : @some : list operation : @parameter%withdraw : @storage
                                   DIG 3;      # @parameter%withdraw : @balance : @some : list operation : @storage
                                   DUP 5;      # @storage : @parameter%withdraw : @balance : @some : list operation : @storage
                                   CAR;        # pair (nat %borrowedTokens) (pair (int %interestIndex) (bool %isLiquidated)) : @parameter%withdraw : @balance : @some : list operation : @storage
                                   GET 3;      # int : @parameter%withdraw : @balance : @some : list operation : @storage
                                   PAIR;       # pair int @parameter%withdraw : @balance : @some : list operation : @storage
                                   DUP 5;      # @storage : pair int @parameter%withdraw : @balance : @some : list operation : @storage
                                   GET 6;      # int : pair int @parameter%withdraw : @balance : @some : list operation : @storage
                                   PAIR;       # pair int (pair int @parameter%withdraw) : @balance : @some : list operation : @storage
                                   DUP 5;      # @storage : pair int (pair int @parameter%withdraw) : @balance : @some : list operation : @storage
                                   CAR;        # pair (nat %borrowedTokens) (pair (int %interestIndex) (bool %isLiquidated)) : pair int (pair int @parameter%withdraw) : @balance : @some : list operation : @storage
                                   GET 4;      # bool : pair int (pair int @parameter%withdraw) : @balance : @some : list operation : @storage
                                   PAIR;       # pair bool (pair int (pair int @parameter%withdraw)) : @balance : @some : list operation : @storage
                                   DUP 5;      # @storage : pair bool (pair int (pair int @parameter%withdraw)) : @balance : @some : list operation : @storage
                                   CAR;        # pair (nat %borrowedTokens) (pair (int %interestIndex) (bool %isLiquidated)) : pair bool (pair int (pair int @parameter%withdraw)) : @balance : @some : list operation : @storage
                                   CAR;        # nat : pair bool (pair int (pair int @parameter%withdraw)) : @balance : @some : list operation : @storage
                                   PAIR;       # pair nat (pair bool (pair int (pair int @parameter%withdraw))) : @balance : @some : list operation : @storage
                                   PUSH nat 1000000000000; # nat : pair nat (pair bool (pair int (pair int @parameter%withdraw))) : @balance : @some : list operation : @storage
                                   PUSH mutez 1; # mutez : nat : pair nat (pair bool (pair int (pair int @parameter%withdraw))) : @balance : @some : list operation : @storage
                                   BALANCE;    # @balance : mutez : nat : pair nat (pair bool (pair int (pair int @parameter%withdraw))) : @balance : @some : list operation : @storage
                                   EDIV;       # option (pair nat mutez) : nat : pair nat (pair bool (pair int (pair int @parameter%withdraw))) : @balance : @some : list operation : @storage
                                   IF_NONE
                                     {
                                       UNIT;       # unit : nat : pair nat (pair bool (pair int (pair int @parameter%withdraw))) : @balance : @some : list operation : @storage
                                       FAILWITH;   # FAILED
                                     }
                                     {}; # @some : nat : pair nat (pair bool (pair int (pair int @parameter%withdraw))) : @balance : @some : list operation : @storage
                                   CAR;        # nat : nat : pair nat (pair bool (pair int (pair int @parameter%withdraw))) : @balance : @some : list operation : @storage
                                   MUL;        # nat : pair nat (pair bool (pair int (pair int @parameter%withdraw))) : @balance : @some : list operation : @storage
                                   PAIR;       # pair nat (pair nat (pair bool (pair int (pair int @parameter%withdraw)))) : @balance : @some : list operation : @storage
                                   DUP 5;      # @storage : pair nat (pair nat (pair bool (pair int (pair int @parameter%withdraw)))) : @balance : @some : list operation : @storage
                                   GET 5;      # address : pair nat (pair nat (pair bool (pair int (pair int @parameter%withdraw)))) : @balance : @some : list operation : @storage
                                   PAIR;       # pair address (pair nat (pair nat (pair bool (pair int (pair int @parameter%withdraw))))) : @balance : @some : list operation : @storage
                                   SELF_ADDRESS; # @self : pair address (pair nat (pair nat (pair bool (pair int (pair int @parameter%withdraw))))) : @balance : @some : list operation : @storage
                                   PAIR;       # pair @self (pair address (pair nat (pair nat (pair bool (pair int (pair int @parameter%withdraw)))))) : @balance : @some : list operation : @storage
                                   TRANSFER_TOKENS; # operation : list operation : @storage
                                   CONS;       # list operation : @storage
                                 }; # list operation : pair (pair nat (pair int bool)) (pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens)))
                             }; # list operation : pair (pair nat (pair int bool)) (pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens)))
                         }; # list operation : pair (pair nat (pair int bool)) (pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens)))
                       PAIR;       # pair (list operation) (pair (pair nat (pair int bool)) (pair (address %ovenProxyContractAddress) (pair (address %owner) (int %stabilityFeeTokens))))
                     };
                 }; # operation : address : list operation : @storage
                PAIR;       # pair operation address : list operation : @storage
                # sp.operations().push(create_contract_oven-factory_102.value.operation) # pair operation address : list operation : @storage
                DUP;        # pair operation address : pair operation address : list operation : @storage
                DUG 2;      # pair operation address : list operation : pair operation address : @storage
                CAR;        # operation : list operation : pair operation address : @storage
                CONS;       # list operation : pair operation address : @storage
                # sp.transfer((create_contract_oven-factory_102.value.address, self.data.makeOvenOwner.open_some()), sp.tez(0), sp.contract(sp.TPair(sp.TAddress, sp.TAddress), self.data.ovenRegistryContractAddress, entry_point='addOven').open_some()) # list operation : pair operation address : @storage
                DUP 3;      # @storage : list operation : pair operation address : @storage
                GET 5;      # address : list operation : pair operation address : @storage
                CONTRACT %addOven (pair address address); # option (contract (pair address address)) : list operation : pair operation address : @storage
                IF_NONE
                  {
                    UNIT;       # unit : list operation : pair operation address : @storage
                    FAILWITH;   # FAILED
                  }
                  {}; # @some : list operation : pair operation address : @storage
                PUSH mutez 0; # mutez : @some : list operation : pair operation address : @storage
                DUP 5;      # @storage : mutez : @some : list operation : pair operation address : @storage
                CAR;        # pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : mutez : @some : list operation : pair operation address : @storage
                GET 4;      # option address : mutez : @some : list operation : pair operation address : @storage
                IF_NONE
                  {
                    UNIT;       # unit : mutez : @some : list operation : pair operation address : @storage
                    FAILWITH;   # FAILED
                  }
                  {}; # @some : mutez : @some : list operation : pair operation address : @storage
                DIG 4;      # pair operation address : @some : mutez : @some : list operation : @storage
                CDR;        # address : @some : mutez : @some : list operation : @storage
                PAIR;       # pair address @some : mutez : @some : list operation : @storage
                TRANSFER_TOKENS; # operation : list operation : @storage
                CONS;       # list operation : @storage
                SWAP;       # @storage : list operation
                # self.data.state = 0 # @storage : list operation
                PUSH int 0; # int : @storage : list operation
                UPDATE 6;   # @storage : list operation
                # self.data.makeOvenOwner = sp.none # @storage : list operation
                UNPAIR;     # pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : list operation
                UNPAIR;     # address : pair (option %initialDelegate key_hash) (option %makeOvenOwner address) : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : list operation
                SWAP;       # pair (option %initialDelegate key_hash) (option %makeOvenOwner address) : address : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : list operation
                CAR;        # option key_hash : address : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : list operation
                NONE address; # option address : option key_hash : address : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : list operation
                SWAP;       # option key_hash : option address : address : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : list operation
                PAIR;       # pair (option key_hash) (option address) : address : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : list operation
                SWAP;       # address : pair (option key_hash) (option address) : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : list operation
                PAIR;       # pair address (pair (option key_hash) (option address)) : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : list operation
                PAIR;       # pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))) : list operation
                SWAP;       # list operation : pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
              }
              {
                SWAP;       # @storage : @parameter%setGovernorContract
                # == setGovernorContract ==
                # sp.verify(sp.sender == self.data.governorContractAddress, 4) # @storage : @parameter%setGovernorContract
                DUP;        # @storage : @storage : @parameter%setGovernorContract
                DUG 2;      # @storage : @parameter%setGovernorContract : @storage
                CAR;        # pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : @parameter%setGovernorContract : @storage
                CAR;        # address : @parameter%setGovernorContract : @storage
                SENDER;     # @sender : address : @parameter%setGovernorContract : @storage
                COMPARE;    # int : @parameter%setGovernorContract : @storage
                EQ;         # bool : @parameter%setGovernorContract : @storage
                IF
                  {}
                  {
                    PUSH int 4; # int : @parameter%setGovernorContract : @storage
                    FAILWITH;   # FAILED
                  }; # @parameter%setGovernorContract : @storage
                SWAP;       # @storage : @parameter%setGovernorContract
                # self.data.governorContractAddress = params # @storage : @parameter%setGovernorContract
                UNPAIR;     # pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : @parameter%setGovernorContract
                CDR;        # pair (option %initialDelegate key_hash) (option %makeOvenOwner address) : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : @parameter%setGovernorContract
                DIG 2;      # @parameter%setGovernorContract : pair (option %initialDelegate key_hash) (option %makeOvenOwner address) : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))
                PAIR;       # pair @parameter%setGovernorContract (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))
                PAIR;       # pair (pair @parameter%setGovernorContract (pair (option %initialDelegate key_hash) (option %makeOvenOwner address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
                NIL operation; # list operation : pair (pair @parameter%setGovernorContract (pair (option %initialDelegate key_hash) (option %makeOvenOwner address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
              }; # list operation : pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
          }; # list operation : pair (pair address (pair (option key_hash) (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
      }
      {
        IF_LEFT
          {
            IF_LEFT
              {
                SWAP;       # @storage : @parameter%setInitialDelegate
                # == setInitialDelegate ==
                # sp.verify(sp.sender == self.data.governorContractAddress, 4) # @storage : @parameter%setInitialDelegate
                DUP;        # @storage : @storage : @parameter%setInitialDelegate
                DUG 2;      # @storage : @parameter%setInitialDelegate : @storage
                CAR;        # pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : @parameter%setInitialDelegate : @storage
                CAR;        # address : @parameter%setInitialDelegate : @storage
                SENDER;     # @sender : address : @parameter%setInitialDelegate : @storage
                COMPARE;    # int : @parameter%setInitialDelegate : @storage
                EQ;         # bool : @parameter%setInitialDelegate : @storage
                IF
                  {}
                  {
                    PUSH int 4; # int : @parameter%setInitialDelegate : @storage
                    FAILWITH;   # FAILED
                  }; # @parameter%setInitialDelegate : @storage
                SWAP;       # @storage : @parameter%setInitialDelegate
                # self.data.initialDelegate = params # @storage : @parameter%setInitialDelegate
                UNPAIR;     # pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : @parameter%setInitialDelegate
                UNPAIR;     # address : pair (option %initialDelegate key_hash) (option %makeOvenOwner address) : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : @parameter%setInitialDelegate
                SWAP;       # pair (option %initialDelegate key_hash) (option %makeOvenOwner address) : address : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : @parameter%setInitialDelegate
                CDR;        # option address : address : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : @parameter%setInitialDelegate
                DIG 3;      # @parameter%setInitialDelegate : option address : address : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))
                PAIR;       # pair @parameter%setInitialDelegate (option address) : address : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))
                SWAP;       # address : pair @parameter%setInitialDelegate (option address) : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))
                PAIR;       # pair address (pair @parameter%setInitialDelegate (option address)) : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state))
                PAIR;       # pair (pair address (pair @parameter%setInitialDelegate (option address))) (pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)))
              }
              {
                SWAP;       # @storage : @parameter%setMinterContract
                # == setMinterContract ==
                # sp.verify(sp.sender == self.data.governorContractAddress, 4) # @storage : @parameter%setMinterContract
                DUP;        # @storage : @storage : @parameter%setMinterContract
                DUG 2;      # @storage : @parameter%setMinterContract : @storage
                CAR;        # pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : @parameter%setMinterContract : @storage
                CAR;        # address : @parameter%setMinterContract : @storage
                SENDER;     # @sender : address : @parameter%setMinterContract : @storage
                COMPARE;    # int : @parameter%setMinterContract : @storage
                EQ;         # bool : @parameter%setMinterContract : @storage
                IF
                  {}
                  {
                    PUSH int 4; # int : @parameter%setMinterContract : @storage
                    FAILWITH;   # FAILED
                  }; # @parameter%setMinterContract : @storage
                SWAP;       # @storage : @parameter%setMinterContract
                # self.data.minterContractAddress = params # @storage : @parameter%setMinterContract
                UNPAIR;     # pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : @parameter%setMinterContract
                SWAP;       # pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : @parameter%setMinterContract
                UNPAIR;     # pair (address %minterContractAddress) (address %ovenProxyContractAddress) : pair (address %ovenRegistryContractAddress) (int %state) : pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : @parameter%setMinterContract
                CDR;        # address : pair (address %ovenRegistryContractAddress) (int %state) : pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : @parameter%setMinterContract
                DIG 3;      # @parameter%setMinterContract : address : pair (address %ovenRegistryContractAddress) (int %state) : pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address))
                PAIR;       # pair @parameter%setMinterContract address : pair (address %ovenRegistryContractAddress) (int %state) : pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address))
                PAIR;       # pair (pair @parameter%setMinterContract address) (pair (address %ovenRegistryContractAddress) (int %state)) : pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address))
                SWAP;       # pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : pair (pair @parameter%setMinterContract address) (pair (address %ovenRegistryContractAddress) (int %state))
                PAIR;       # pair (pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address))) (pair (pair @parameter%setMinterContract address) (pair (address %ovenRegistryContractAddress) (int %state)))
              }; # pair (pair address (pair (option key_hash) (option address))) (pair (pair address address) (pair (address %ovenRegistryContractAddress) (int %state)))
          }
          {
            IF_LEFT
              {
                SWAP;       # @storage : @parameter%setOvenProxyContract
                # == setOvenProxyContract ==
                # sp.verify(sp.sender == self.data.governorContractAddress, 4) # @storage : @parameter%setOvenProxyContract
                DUP;        # @storage : @storage : @parameter%setOvenProxyContract
                DUG 2;      # @storage : @parameter%setOvenProxyContract : @storage
                CAR;        # pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : @parameter%setOvenProxyContract : @storage
                CAR;        # address : @parameter%setOvenProxyContract : @storage
                SENDER;     # @sender : address : @parameter%setOvenProxyContract : @storage
                COMPARE;    # int : @parameter%setOvenProxyContract : @storage
                EQ;         # bool : @parameter%setOvenProxyContract : @storage
                IF
                  {}
                  {
                    PUSH int 4; # int : @parameter%setOvenProxyContract : @storage
                    FAILWITH;   # FAILED
                  }; # @parameter%setOvenProxyContract : @storage
                SWAP;       # @storage : @parameter%setOvenProxyContract
                # self.data.ovenProxyContractAddress = params # @storage : @parameter%setOvenProxyContract
                UNPAIR;     # pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : @parameter%setOvenProxyContract
                SWAP;       # pair (pair (address %minterContractAddress) (address %ovenProxyContractAddress)) (pair (address %ovenRegistryContractAddress) (int %state)) : pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : @parameter%setOvenProxyContract
                UNPAIR;     # pair (address %minterContractAddress) (address %ovenProxyContractAddress) : pair (address %ovenRegistryContractAddress) (int %state) : pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : @parameter%setOvenProxyContract
                CAR;        # address : pair (address %ovenRegistryContractAddress) (int %state) : pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : @parameter%setOvenProxyContract
                DIG 3;      # @parameter%setOvenProxyContract : address : pair (address %ovenRegistryContractAddress) (int %state) : pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address))
                SWAP;       # address : @parameter%setOvenProxyContract : pair (address %ovenRegistryContractAddress) (int %state) : pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address))
                PAIR;       # pair address @parameter%setOvenProxyContract : pair (address %ovenRegistryContractAddress) (int %state) : pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address))
                PAIR;       # pair (pair address @parameter%setOvenProxyContract) (pair (address %ovenRegistryContractAddress) (int %state)) : pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address))
                SWAP;       # pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : pair (pair address @parameter%setOvenProxyContract) (pair (address %ovenRegistryContractAddress) (int %state))
                PAIR;       # pair (pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address))) (pair (pair address @parameter%setOvenProxyContract) (pair (address %ovenRegistryContractAddress) (int %state)))
              }
              {
                SWAP;       # @storage : @parameter%setOvenRegistryContract
                # == setOvenRegistryContract ==
                # sp.verify(sp.sender == self.data.governorContractAddress, 4) # @storage : @parameter%setOvenRegistryContract
                DUP;        # @storage : @storage : @parameter%setOvenRegistryContract
                DUG 2;      # @storage : @parameter%setOvenRegistryContract : @storage
                CAR;        # pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address)) : @parameter%setOvenRegistryContract : @storage
                CAR;        # address : @parameter%setOvenRegistryContract : @storage
                SENDER;     # @sender : address : @parameter%setOvenRegistryContract : @storage
                COMPARE;    # int : @parameter%setOvenRegistryContract : @storage
                EQ;         # bool : @parameter%setOvenRegistryContract : @storage
                IF
                  {}
                  {
                    PUSH int 4; # int : @parameter%setOvenRegistryContract : @storage
                    FAILWITH;   # FAILED
                  }; # @parameter%setOvenRegistryContract : @storage
                # self.data.ovenRegistryContractAddress = params # @parameter%setOvenRegistryContract : @storage
                UPDATE 5;   # @storage
              }; # pair (pair (address %governorContractAddress) (pair (option %initialDelegate key_hash) (option %makeOvenOwner address))) (pair (pair address address) (pair (address %ovenRegistryContractAddress) (int %state)))
          }; # pair (pair address (pair (option key_hash) (option address))) (pair (pair address address) (pair (address %ovenRegistryContractAddress) (int %state)))
        NIL operation; # list operation : pair (pair address (pair (option key_hash) (option address))) (pair (pair address address) (pair (address %ovenRegistryContractAddress) (int %state)))
      }; # list operation : pair (pair address (pair (option key_hash) (option address))) (pair (pair address address) (pair (address %ovenRegistryContractAddress) (int %state)))
    NIL operation; # list operation : list operation : pair (pair address (pair (option key_hash) (option address))) (pair (pair address address) (pair (address %ovenRegistryContractAddress) (int %state)))
    SWAP;       # list operation : list operation : pair (pair address (pair (option key_hash) (option address))) (pair (pair address address) (pair (address %ovenRegistryContractAddress) (int %state)))
    ITER
      {
        CONS;       # list operation : pair (pair address (pair (option key_hash) (option address))) (pair (pair address address) (pair (address %ovenRegistryContractAddress) (int %state)))
      }; # list operation : pair (pair address (pair (option key_hash) (option address))) (pair (pair address address) (pair (address %ovenRegistryContractAddress) (int %state)))
    PAIR;       # pair (list operation) (pair (pair address (pair (option key_hash) (option address))) (pair (pair address address) (pair (address %ovenRegistryContractAddress) (int %state))))
  };